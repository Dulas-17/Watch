<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>DULAS — Advanced Decoder</title>
<style>
  :root{
    --bg1:#06121a; --bg2:#083247;
    --card: rgba(255,255,255,0.03);
    --accent:#00e6a8;
    --success: #00c896;
    --error: #ff4d7c;
    --warning: #ffb44d;
    font-family: Inter, system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial;
  }
  body{margin:0; min-height:100vh; background: linear-gradient(180deg,var(--bg1),var(--bg2)); color:#e6fff6; display:flex; align-items:center; justify-content:center; padding:18px}
  .wrap{width:100%; max-width:920px; background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(0,0,0,0.08)); border-radius:14px; padding:18px; box-shadow: 0 8px 24px rgba(0,0,0,0.2)}
  header{display:flex; gap:12px; align-items:center; justify-content:space-between; flex-wrap:wrap}
  h1{margin:0; font-size:20px}
  .controls{display:flex; gap:8px; align-items:center; flex-wrap:wrap}
  input[type=file],input[type=password],select{padding:10px;border-radius:10px;border:none;background:var(--card);color:inherit; width: 100%; box-sizing: border-box;}
  input[type=password] {border: 1px solid rgba(255,255,255,0.06);}
  button.primary{padding:10px 14px;border-radius:10px;border:none;background:linear-gradient(90deg,#00e6a8,#7cffc9);color:#012;font-weight:700;cursor:pointer; transition: all 0.2s ease;}
  button.primary:hover {transform: translateY(-2px); box-shadow: 0 4px 12px rgba(0,230,168,0.3);}
  button.primary:disabled {opacity: 0.6; cursor: not-allowed; transform: none;}
  .main{display:flex; gap:16px; margin-top:14px; flex-wrap:wrap}
  .left{flex:1; min-width:240px}
  .right{width:360px; max-width:100%; background:rgba(255,255,255,0.02); padding:12px; border-radius:12px; height:420px; overflow:auto}
  .file-item{display:flex; gap:10px; align-items:center; padding:8px; border-radius:8px; background: rgba(255,255,255,0.02); margin-bottom: 8px; position: relative;}
  .file-item .remove-btn {
    position: absolute;
    top: -5px;
    right: -5px;
    background: var(--error);
    color: white;
    border: none;
    border-radius: 50%;
    width: 20px;
    height: 20px;
    font-size: 12px;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
  }
  .thumb{width:52px;height:52px;border-radius:8px;background:rgba(0,0,0,0.15);display:flex;align-items:center;justify-content:center;overflow:hidden}
  .meta .name{font-size:13px; font-weight: 500;}
  .meta .sub{font-size:12px; opacity:0.7}
  .hint{font-size:13px; opacity:0.9; margin-top: 4px;}
  .result{margin-top:10px; background: rgba(0,0,0,0.1); padding: 12px; border-radius: 8px;}
  audio,video{width:100%; border-radius: 6px;}
  img {max-width: 100%; border-radius: 6px;}
  .password-section {margin-top: 12px; display: none;}
  .status-message {
    padding: 8px 12px;
    border-radius: 6px;
    margin-top: 10px;
    font-size: 13px;
  }
  .status-success {
    background: rgba(0,200,150,0.15);
    color: var(--success);
  }
  .status-error {
    background: rgba(255,77,124,0.15);
    color: var(--error);
  }
  .status-warning {
    background: rgba(255,180,77,0.15);
    color: var(--warning);
  }
  .progress-bar {
    height: 4px;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
    overflow: hidden;
    margin-top: 8px;
  }
  .progress-bar .progress {
    height: 100%;
    background: linear-gradient(90deg, var(--accent), #7cffc9);
    width: 0%;
    transition: width 0.3s ease;
  }
  @media (max-width:700px){ 
    .main{flex-direction:column} 
    .right{height:320px} 
    .controls {
      flex-direction: column;
    }
  }
</style>
</head>
<body>
  <div class="wrap">
    <header>
      <div>
        <h1>DULAS Advanced Decoder</h1>
        <div class="hint">Open .dls files — auto-detects password protection and file types</div>
      </div>

      <div class="controls">
        <input id="dlsInput" type="file" accept=".dls" multiple />
        <button class="primary" id="analyzeBtn">Analyze</button>
      </div>
    </header>

    <div class="main">
      <div class="left">
        <strong>Selected .dls files</strong>
        <div class="progress-bar" id="decodeProgress">
          <div class="progress"></div>
        </div>
        <div id="selectedList" style="margin-top:10px">
          <div class="hint">Choose .dls files and click Analyze to inspect headers.</div>
        </div>

        <div class="password-section" id="passwordSection">
          <label class="hint">Password required:</label>
          <input id="password" type="password" placeholder="Enter password" style="width:100%; margin-top:6px;">
          <div class="hint" style="margin-top: 4px;">This file is password protected</div>
        </div>

        <div style="margin-top:10px">
          <button id="decodeBtn" class="primary">Decode selected</button>
        </div>
        
        <div id="statusMessage" class="status-message"></div>
      </div>

      <aside class="right">
        <strong>Decode output</strong>
        <div id="output" style="margin-top:10px">
          <div class="hint">Decoded files and previews will appear here.</div>
        </div>
      </aside>
    </div>
  </div>

<script>
const enc = new TextEncoder();
const dec = new TextDecoder();

/* Improved keystream generation using PBKDF2-like approach */
async function buildKeystream(password, length, salt = new Uint8Array(16)) {
  if (!password) return null;
  
  const passwordBuffer = enc.encode(password);
  const keyMaterial = await crypto.subtle.importKey(
    'raw',
    passwordBuffer,
    { name: 'PBKDF2' },
    false,
    ['deriveBits']
  );
  
  const key = await crypto.subtle.deriveBits(
    {
      name: 'PBKDF2',
      salt: salt,
      iterations: 100000,
      hash: 'SHA-256'
    },
    keyMaterial,
    length * 8
  );
  
  return new Uint8Array(key);
}

/* Parse .dls format with enhanced error handling */
function parseDulasBuffer(ab) {
  const bytes = new Uint8Array(ab);
  let p = 0;
  
  try {
    // Check minimum size
    if (bytes.length < 14) {
      throw new Error('File too small to be a valid DULAS file');
    }
    
    // Check magic
    const magic = String.fromCharCode(...bytes.slice(p, p + 5));
    p += 5;
    if (magic !== 'DULAS') {
      throw new Error('Not a valid DULAS file (invalid magic)');
    }
    
    const version = bytes[p++];
    if (version !== 1) {
      throw new Error(`Unsupported DULAS version: ${version}`);
    }
    
    const typeByte = bytes[p++];
    const flags = bytes[p++];
    
    // Read salt if present
    let salt = new Uint8Array(0);
    if (flags & 2) { // hasSalt flag
      if (bytes.length < p + 16) {
        throw new Error('File truncated at salt section');
      }
      salt = bytes.slice(p, p + 16);
      p += 16;
    }
    
    // Read name length
    if (bytes.length < p + 2) {
      throw new Error('File truncated at name length section');
    }
    const nameLen = (bytes[p++] << 8) | bytes[p++];
    
    // Read name
    if (bytes.length < p + nameLen) {
      throw new Error('File truncated at name section');
    }
    const nameBytes = bytes.slice(p, p + nameLen);
    p += nameLen;
    
    // Read meta length
    if (bytes.length < p + 4) {
      throw new Error('File truncated at meta length section');
    }
    const metaLen = (bytes[p++] << 24) | (bytes[p++] << 16) | (bytes[p++] << 8) | bytes[p++];
    
    // Read meta
    if (bytes.length < p + metaLen) {
      throw new Error('File truncated at meta section');
    }
    const metaBytes = bytes.slice(p, p + metaLen);
    p += metaLen;
    
    // Remaining bytes are content
    const contentBytes = bytes.slice(p);
    
    const name = dec.decode(nameBytes);
    const metaStr = dec.decode(metaBytes);
    let metaObj = {};
    
    try {
      metaObj = JSON.parse(metaStr);
    } catch (e) {
      console.warn('Failed to parse metadata JSON:', e);
      metaObj = { raw: metaStr };
    }
    
    // Convert type byte to string
    const typeMap = { 1: 'image', 2: 'audio', 3: 'video', 4: 'pdf' };
    const type = typeMap[typeByte] || 'unknown';
    
    return {
      ok: true,
      header: {
        magic,
        version,
        type,
        passwordProtected: !!(flags & 1),
        hasSalt: !!(flags & 2),
        salt,
        fileName: name,
        meta: metaObj,
        originalSize: metaObj.originalSize || null,
        originalType: metaObj.originalType || ''
      },
      contentBytes
    };
  } catch (err) {
    return {
      ok: false,
      error: err.message || String(err)
    };
  }
}

function uint8ToBlobUrl(arr, mime) {
  const blob = new Blob([arr], { type: mime || 'application/octet-stream' });
  return URL.createObjectURL(blob);
}

function showStatus(message, type = 'success') {
  const statusElement = document.getElementById('statusMessage');
  statusElement.textContent = message;
  statusElement.className = `status-message status-${type}`;
}

function showProgress(percent) {
  const progressBar = document.getElementById('decodeProgress');
  const progressElement = progressBar.querySelector('.progress');
  progressBar.style.display = 'block';
  progressElement.style.width = `${percent}%`;
}

function hideProgress() {
  const progressBar = document.getElementById('decodeProgress');
  progressBar.style.display = 'none';
}

/* UI */
const dlsInput = document.getElementById('dlsInput');
const analyzeBtn = document.getElementById('analyzeBtn');
const selectedList = document.getElementById('selectedList');
const output = document.getElementById('output');
const passwordField = document.getElementById('password');
const passwordSection = document.getElementById('passwordSection');
const decodeBtn = document.getElementById('decodeBtn');

let selectedFiles = []; // File objects
let parsedFiles = []; // parsed headers + content

dlsInput.addEventListener('change', e => {
  selectedFiles = Array.from(e.target.files);
  parsedFiles = [];
  selectedList.innerHTML = '';
  passwordSection.style.display = 'none';
  output.innerHTML = '<div class="hint">Choose .dls files and click Analyze to inspect headers.</div>';
  showStatus('');
});

analyzeBtn.addEventListener('click', async () => {
  if (selectedFiles.length === 0) {
    showStatus('No .dls files selected', 'error');
    return;
  }
  
  analyzeBtn.disabled = true;
  parsedFiles = [];
  selectedList.innerHTML = '';
  passwordSection.style.display = 'none';
  showProgress(0);
  output.innerHTML = '<div class="hint">Analyzing headers...</div>';
  
  try {
    for (let i = 0; i < selectedFiles.length; i++) {
      const f = selectedFiles[i];
      showProgress((i / selectedFiles.length) * 50);
      
      try {
        const ab = await f.arrayBuffer();
        const parsed = parseDulasBuffer(ab);
        
        if (!parsed.ok) {
          const errdiv = document.createElement('div');
          errdiv.className = 'status-error';
          errdiv.style.padding = '8px';
          errdiv.style.borderRadius = '6px';
          errdiv.style.marginBottom = '8px';
          errdiv.textContent = `Error reading ${f.name}: ${parsed.error}`;
          selectedList.appendChild(errdiv);
          continue;
        }
        
        parsed.fileRef = f;
        parsedFiles.push(parsed);
        
        // Show parsed header in UI
        const box = document.createElement('div');
        box.className = 'file-item';
        
        const removeBtn = document.createElement('button');
        removeBtn.className = 'remove-btn';
        removeBtn.innerHTML = '×';
        removeBtn.title = 'Remove file';
        removeBtn.addEventListener('click', () => {
          const index = parsedFiles.findIndex(pf => pf.fileRef === f);
          if (index !== -1) {
            parsedFiles.splice(index, 1);
            selectedList.removeChild(box);
          }
        });
        
        const left = document.createElement('div');
        left.style.display = 'flex';
        left.style.gap = '10px';
        left.style.alignItems = 'center';
        left.style.flex = '1';
        
        const thumb = document.createElement('div');
        thumb.className = 'thumb';
        
        // Set appropriate icon based on file type
        const type = parsed.header.type;
        if (type === 'image') {
          thumb.style.background = 'linear-gradient(90deg,#3a3, #060)';
          thumb.innerHTML = '<svg width="22" height="22" viewBox="0 0 24 24" fill="none"><rect width="24" height="24" rx="3" fill="white" /></svg>';
        } else if (type === 'audio') {
          thumb.style.background = 'linear-gradient(90deg,#07a,#045)';
          thumb.innerHTML = '<svg width="22" height="22" viewBox="0 0 24 24"><circle cx="12" cy="12" r="10" fill="white"/></svg>';
        } else if (type === 'video') {
          thumb.style.background = 'linear-gradient(90deg,#a06, #603)';
          thumb.innerHTML = '<svg width="22" height="22" viewBox="0 0 24 24" fill="none"><path d="M17 10.5V7c0-.55-.45-1-1-1H4c-.55 0-1 .45-1 1v10c0 .55.45 1 1 1h12c.55 0 1-.45 1-1v-3.5l4 4v-11l-4 4z" fill="white"/></svg>';
        } else if (type === 'pdf') {
          thumb.style.background = 'linear-gradient(90deg,#c33, #633)';
          thumb.innerHTML = '<svg width="22" height="22" viewBox="0 0 24 24" fill="none"><path d="M14 2H6c-1.1 0-1.99.9-1.99 2L4 20c0 1.1.89 2 1.99 2H18c1.1 0 2-.9 2-2V8l-6-6zM15 18H9v-2h6v2zm0-4H9v-2h6v2zm-2-4V9.5L15.5 10H13z" fill="white"/></svg>';
        } else {
          thumb.style.background = 'rgba(0,0,0,0.3)';
          thumb.innerHTML = '<svg width="22" height="22" viewBox="0 0 24 24" fill="none"><rect width="24" height="24" rx="3" fill="white" /></svg>';
        }
        
        const txt = document.createElement('div');
        txt.innerHTML = `
          <div style="font-weight:700">${parsed.header.fileName}</div>
          <div style="opacity:0.8;font-size:13px">
            ${parsed.header.type} • 
            ${parsed.header.meta.originalSize ? (parsed.header.meta.originalSize / 1024).toFixed(1) + ' KB' : 'size unknown'}
          </div>
        `;
        
        left.appendChild(thumb);
        left.appendChild(txt);
        
        const right = document.createElement('div');
        if (parsed.header.passwordProtected) {
          const ptag = document.createElement('div');
          ptag.textContent = 'Password required';
          ptag.style.color = '#ffd2d2';
          ptag.style.fontWeight = '700';
          ptag.style.fontSize = '13px';
          right.appendChild(ptag);
        } else {
          const ptag = document.createElement('div');
          ptag.textContent = 'No password';
          ptag.style.color = '#c8ffd8';
          ptag.style.fontWeight = '700';
          ptag.style.fontSize = '13px';
          right.appendChild(ptag);
        }
        
        box.appendChild(removeBtn);
        box.appendChild(left);
        box.appendChild(right);
        selectedList.appendChild(box);
        
      } catch (err) {
        const errdiv = document.createElement('div');
        errdiv.className = 'status-error';
        errdiv.style.padding = '8px';
        errdiv.style.borderRadius = '6px';
        errdiv.style.marginBottom = '8px';
        errdiv.textContent = `Error processing ${f.name}: ${err.message || err}`;
        selectedList.appendChild(errdiv);
      }
    }
    
    showProgress(100);
    
    // Check if any files need password
    const needsPassword = parsedFiles.some(p => p.header.passwordProtected);
    if (needsPassword) {
      passwordSection.style.display = 'block';
      showStatus('Some files require a password', 'warning');
    } else {
      showStatus(`Analyzed ${parsedFiles.length} file(s) successfully`, 'success');
    }
    
    output.innerHTML = `<div class="hint">Analysis complete. ${parsedFiles.length} file(s) ready for decoding.</div>`;
    
  } catch (err) {
    console.error('Analysis error:', err);
    showStatus(`Analysis error: ${err.message || err}`, 'error');
    output.innerHTML = '<div class="hint">An error occurred during analysis.</div>';
  } finally {
    analyzeBtn.disabled = false;
    setTimeout(() => hideProgress(), 500);
  }
});

decodeBtn.addEventListener('click', async () => {
  if (parsedFiles.length === 0) {
    showStatus('Analyze .dls files first', 'error');
    return;
  }
  
  const pwd = passwordField.value || null;
  decodeBtn.disabled = true;
  showProgress(0);
  output.innerHTML = '';
  
  try {
    let successCount = 0;
    
    for (let i = 0; i < parsedFiles.length; i++) {
      const p = parsedFiles[i];
      const header = p.header;
      showProgress((i / parsedFiles.length) * 100);
      
      output.innerHTML += `<div class="hint">Decoding ${header.fileName}...</div>`;
      
      try {
        let plain = p.contentBytes;
        
        // Decrypt if password protected
        if (header.passwordProtected) {
          if (!pwd) {
            output.innerHTML += `<div class="status-error">${header.fileName} requires a password. Skipping.</div>`;
            continue;
          }
          
          try {
            const ks = await buildKeystream(pwd, p.contentBytes.length, header.salt);
            const temp = new Uint8Array(p.contentBytes.length);
            for (let i = 0; i < p.contentBytes.length; i++) {
              temp[i] = p.contentBytes[i] ^ ks[i];
            }
            plain = temp;
          } catch (e) {
            output.innerHTML += `<div class="status-error">Failed to decrypt ${header.fileName} — wrong password?</div>`;
            continue;
          }
        }
        
        // Determine MIME type
        let mime = header.meta.originalType || '';
        if (!mime) {
          // Fallback MIME types based on file type
          const mimeMap = {
            image: 'image/jpeg',
            audio: 'audio/mpeg',
            video: 'video/mp4',
            pdf: 'application/pdf'
          };
          mime = mimeMap[header.type] || 'application/octet-stream';
        }
        
        // Create blob URL for preview/download
        const url = uint8ToBlobUrl(plain, mime);
        
        // Create download link
        const dl = document.createElement('a');
        dl.href = url;
        dl.download = header.fileName;
        dl.textContent = `Save ${header.fileName}`;
        dl.style.display = 'inline-block';
        dl.style.marginBottom = '6px';
        dl.style.padding = '8px 10px';
        dl.style.borderRadius = '8px';
        dl.style.background = 'linear-gradient(90deg,#fff,#dff)';
        dl.style.color = '#012';
        dl.style.fontWeight = '700';
        dl.style.textDecoration = 'none';
        
        // Create preview container
        const wrap = document.createElement('div');
        wrap.className = 'result';
        wrap.style.marginTop = '8px';
        
        // Add download link
        wrap.appendChild(dl);
        
        // Add appropriate preview based on file type
        if (header.type === 'image') {
          const img = document.createElement('img');
          img.src = url;
          img.alt = header.fileName;
          img.onerror = () => {
            img.style.display = 'none';
            wrap.innerHTML += '<div class="hint">Image preview not available</div>';
          };
          wrap.appendChild(img);
        } else if (header.type === 'audio') {
          const audio = document.createElement('audio');
          audio.controls = true;
          audio.src = url;
          audio.onerror = () => {
            audio.style.display = 'none';
            wrap.innerHTML += '<div class="hint">Audio preview not available</div>';
          };
          wrap.appendChild(audio);
        } else if (header.type === 'video') {
          const video = document.createElement('video');
          video.controls = true;
          video.src = url;
          video.style.maxHeight = '200px';
          video.onerror = () => {
            video.style.display = 'none';
            wrap.innerHTML += '<div class="hint">Video preview not available</div>';
          };
          wrap.appendChild(video);
        } else {
          // For PDFs and unknown types, just show download link
          wrap.innerHTML += `<div class="hint">${header.type.toUpperCase()} file - download to view</div>`;
        }
        
        output.appendChild(wrap);
        successCount++;
        
      } catch (err) {
        output.innerHTML += `<div class="status-error">Error decoding ${header.fileName}: ${err.message || err}</div>`;
      }
    }
    
    showProgress(100);
    
    if (successCount > 0) {
      showStatus(`Successfully decoded ${successCount} file(s)`, 'success');
      output.innerHTML = `<div class="hint">Decoded ${successCount} file(s) successfully.</div>` + output.innerHTML;
    } else {
      showStatus('No files were successfully decoded', 'error');
      output.innerHTML = '<div class="hint">No files were successfully decoded.</div>';
    }
    
  } catch (err) {
    console.error('Decoding error:', err);
    showStatus(`Decoding error: ${err.message || err}`, 'error');
    output.innerHTML = '<div class="hint">An error occurred during decoding.</div>';
  } finally {
    decodeBtn.disabled = false;
    setTimeout(() => hideProgress(), 500);
  }
});
</script>
</body>
</html>